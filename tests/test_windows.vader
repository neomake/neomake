Include: include/setup.vader

Execute (shell options):
  Log 'SHELL='.$SHELL
  Log neomake#utils#redir('verb set shell?')
  Log neomake#utils#redir('verb set shellcmdflag?')
  Log '+shellslash: '.exists('+shellslash')
  if exists('+shellslash')
    Log '&shellslash: '.&shellslash
    Log neomake#utils#redir('verb set shellslash?')
  endif

Execute (getcwd: trailing slash on root (cd)):
  let old_cd = getcwd()
  let root = fnamemodify('/', ':p')
  Log 'cd '.root
  exe 'cd '.root
  try
    let cwd = getcwd()
    if !exists('+shellslash') || &shellslash
      AssertEqual cwd[-1:], '/'
    else
      AssertEqual cwd[-1:], '\'
    endif
  finally
    exe 'cd '.old_cd
  endtry

Execute (TODO: getcwd: trailing slash on root (lcd)):
  " https://github.com/vim/vim/issues/3399 (fixed in 8.1.0343)
  new
  let root = fnamemodify('/', ':p')
  Log 'lcd '.root
  exe 'lcd '.root
  let cwd = getcwd()
  if !exists('+shellslash') || &shellslash
    AssertEqual cwd[-1:], '/'
  else
    AssertEqual cwd[-1:], '\'
  endif
  bwipe

Execute (TODO: fnamemodify :p: trailing slash on root):
  " https://github.com/vim/vim/issues/3399 ? (fixed in 8.1.0343)
  new
  let root = fnamemodify('/', ':p')
  Log 'lcd '.root
  exe 'lcd '.root
  Log 'getcwd: '.getcwd()
  let cwd = fnamemodify(getcwd(), ':p')
  Log 'cwd: '.cwd
  if !exists('+shellslash') || &shellslash
    AssertEqual cwd[-1:], '/'
  else
    AssertEqual cwd[-1:], '\'
  endif
  bwipe

Execute (TODO: fnamemodify :p: trailing slash on non-root):
  " https://github.com/vim/vim/issues/3399 ? (fixed in 8.1.0343)
  new
  Log 'lcd '.fnamemodify(tempname(), ':h')
  exe 'lcd '.fnamemodify(tempname(), ':h')
  Log getcwd()
  let cwd = fnamemodify(getcwd(), ':p')
  Log cwd
  if !exists('+shellslash') || &shellslash
    AssertEqual cwd[-1:], '/'
  else
    AssertEqual cwd[-1:], '\'
  endif
  bwipe

Execute (printf 1):
  let maker = {'exe': 'printf', 'args': ['1']}
  CallNeomake 0, [maker]
  AssertEqual map(getqflist(), 'v:val.text'), ['1']

" Execute (g:NeomakeTestsCreateExe):
"   let exe = g:NeomakeTestsCreateExe('foo', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)
"
" Execute (g:NeomakeTestsCreateExe: cmd):
"   let exe = g:NeomakeTestsCreateExe('foo.cmd', ['#!/bin/sh', 'printf 1'])
"   Log 'exe: '.exe
"   let exe_path = exepath('foo')
"   Log exe_path
"   let exe_path = exepath('foo.cmd')
"   Log exe_path
"   AssertEqual system(exe), "1"
"   Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe):
  let exe = g:NeomakeTestsCreateExe('foo', ['printf 1'])
  AssertEqual system(exe), "1"
  if neomake#utils#IsRunningWindows()
    " Creates a wrapper .cmd script.
    Log exepath('foo')
    Log exepath('foo.cmd')
    Assert !empty(exepath('foo.cmd'))
  endif
  Log $PATH
  Log executable('foo')
  Assert !empty(exepath('foo'))

Execute (g:NeomakeTestsCreateExe: sh):
  let exe = g:NeomakeTestsCreateExe('foo.sh', ['#!/bin/sh', 'printf 1'])
  Log 'exe: '.exe
  let exe_path = exepath('foo')
  Log exe_path
  let exe_path = exepath('foo.sh')
  Log exe_path
  AssertEqual system(exe), "1"
  Assert len(exe_path)

Execute (g:NeomakeTestsCreateExe: win cmd):
  if neomake#utils#IsRunningWindows()
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['@echo off', 'echo 1'])
    AssertEqual fnamemodify(exepath('foo.CMD'), ':t'), 'foo.CMD'
    if has('nvim')
      " With &shell == 'cmd.exe' at least.
      AssertEqual fnamemodify(exepath('foo'), ':t'), 'foo'
    else
      AssertEqual fnamemodify(exepath('foo'), ':t'), 'foo.CMD'
    endif
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  else
    let exe = g:NeomakeTestsCreateExe('foo.cmd', ['echo 1'])
    AssertEqual fnamemodify(exepath('foo.cmd'), ':t'), 'foo.cmd'
  endif
  AssertEqual system(exe), "1\n"

Execute (escaping):
  function! s:run_cmd(cmd)
    let s:exit = []

    Log '== cmd: '.(type(a:cmd) == type('') ? a:cmd : string(a:cmd))

    if exists('*job_start')
      let s:output = ''
      let s:err = ''
      let s:closed = 0
      unlet! s:exit

      function! s:output(channel, data)
        let s:output .= a:data
      endfunction

      function! s:err(channel, data)
        let s:err .= a:data
      endfunction

      function! s:exit(job, status)
        let s:exit = a:status
      endfunction

      function! s:close_cb(channel)
        while ch_status(a:channel, {'part': 'out'}) == 'buffered'
          sleep 10m
        endwhile
        let s:closed = 1
      endfunction

      let job = job_start(a:cmd, {
      \ 'out_cb': function('s:output'),
      \ 'err_cb': function('s:err'),
      \ 'exit_cb': function('s:exit'),
      \ 'close_cb': function('s:close_cb'),
      \ 'out_mode': 'raw',
      \ 'err_mode': 'raw',
      \ })

      while empty(s:closed)
        sleep 10m
      endwhile
      return [s:output, s:err, s:exit]
    else
      let job = {'output': [''], 'err': ['']}

      function! job.on_stdout(_job_id, data, _event)
      Log a:data
        let self.output[-1] .= a:data[0]
        call extend(self.output, a:data[1:])
      endfunction

      function! job.on_stderr(_job_id, data, _event)
        let self.err[-1] .= a:data[0]
        call extend(self.err, a:data[1:])
      endfunction

      function! job.on_exit(_job_id, data, _event)
        let self.exit = a:data
      endfunction

      call jobwait([jobstart(a:cmd, job)])
      return [join(job.output, "\n"), join(job.err, "\n"), job.exit]
    endif
    return [our, err]
  endfunction

  AssertEqual s:run_cmd('bash -c "printf 1"'), ['1', '', 0]
  AssertEqual s:run_cmd('bash -c "echo 1; echo 2"'), ["1\n2\n", '', 0]

  AssertEqual s:run_cmd('bash -c "printf ''%s'' 1 2"'), ['12', '', 0]

  if has('nvim')
    AssertEqual s:run_cmd(['bash', '-c', "printf '%s\n' 1 2"]), ["1\n2\n", '', 0]
    AssertEqual s:run_cmd('bash -c "printf ''%s\n'' 1 2"'), ["1\n2\n", '', 0]
  else
    " XXX
    AssertEqual s:run_cmd('bash -c "printf ''%s\n'' 1 2"'), ["1\n2\n", '', 0]
    " XXX
    AssertEqual s:run_cmd(['bash', '-c', 'printf "%s\n" 1 2']), ["1\n2\n", '', 0]
  endif

  if neomake#utils#IsRunningWindows()
    AssertEqual s:run_cmd('cmd /c "echo 1"'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c "echo 1; echo 2"'), ["1; echo 2\r\n", '', 0]

    Save &shell, &shellcmdflag, &shellxquote
    let &shell='cmd.exe'
    set shellcmdflag& shellxquote&
    " NOTE: hangs nvim, when using bash as shell.
    AssertEqual s:run_cmd('cmd /c echo 1'), ["1\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c echo 1 2'), ["1 2\r\n", '', 0]

    " cmd.exe with parenthesis.
    AssertEqual s:run_cmd('cmd /c (echo 1 2)'), ["1 2\r\n", '', 0]
    AssertEqual s:run_cmd('cmd /c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]

    " bash with parenthesis (does not work).
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''")'), ["\"1 '2'\"\r\n", '', 0]
    " AssertEqual s:run_cmd('bash -c (echo "1 ''2''";)'), ["\"1 '2'\"\r\n", '', 0]

    AssertEqual s:run_cmd('cmd.exe /c echo "1 1"'), ["\"1 1\"\r\n", '', 0]
  endif

Execute (tempname):
  let tmpdir = tempname()
  Log tmpdir

Execute (… (ellipsis)):
  " Neovim on Windows:
  " Calling User autocmd NeomakeCountsChanged with context: {'jobinfo': 'ΓÇª', 'reset': 0}.
  Log '…'
  Log "…"

Execute (mkdir, writefile):
  new
  let tmp = tempname()
  call mkdir(tmp, 'p')
  Log tmp
  exe 'lcd '.tmp

  if has('nvim') && (!exists('+shellslash') || &shellslash)
    " Vim(call):E739: Cannot create directory: pylama/subdir
    call mkdir('pylama/subdir', 'p')
  else
    call mkdir('pylama\subdir', 'p')
  endif
  call writefile([], 'pylama/setup.cfg')
  lcd pylama/subdir
  Log getcwd()
  Log filereadable('../setup.cfg')
  Log neomake#utils#FindGlobFile('{pylama.ini,setup.cfg,tox.ini,pytest.ini}')
  Log neomake#utils#FindGlobFile('setup.cfg')
  bwipe

Execute (NeomakeTestsCommandMaker with semicolons):
  new
  Save &shell, &shellcmdflag
  let &shell = 'cmd'
  let &shellcmdflag = '/s /c'
  let maker = NeomakeTestsCommandMaker('cmd-with-semicolon', 'echo 1; echo 2')
  AssertEqual maker.args, ['/s', '/c', 'echo 1& echo 2']
  if executable('cmd')
    CallNeomake 1, [maker]
    AssertEqual map(getloclist(0), 'v:val.text'), ['1', '2']
  endif

  let maker = NeomakeTestsCommandMaker('stderr_maker',
  \ 'echo failed to run >&2; echo because something bad happened >&2')
  AssertEqual maker.args, ['/s', '/c', 'echo failed to run >&2& echo because something bad happened >&2']
  if executable('cmd')
    CallNeomake 1, [maker]
    " Keeps space at end.
    AssertEqual map(getloclist(0), 'v:val.text'), ['failed to run ', 'because something bad happened ']
  endif
  bwipe

Execute (Warns when removal of tempfiles fails):
  if neomake#has_async_support()
    Log neomake#utils#redir('au User NeomakeFinished')
    Log neomake#utils#redir('au User')
    new
    let maker = {'exe': 'true'}
    call neomake#Make(1, [maker])
    AssertNeomakeMessage '\v^Using tempfile for unnamed buffer: "(.*)"', 3
    let tempfile_name = g:neomake_test_matchlist[1]
    call delete(tempfile_name)
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage printf('Failed to remove temporary file: "%s".', tempfile_name), 1
    bwipe
  else
    NeomakeTestsSkip 'no async support.'
  endif

Execute (filewritable/mkdir):
  let tmpdir = tempname()
  call mkdir(tmpdir, 'p', 0550)
  Log 'filewritable 1: '.filewritable(tmpdir)
  call setfperm(tmpdir, 'r--r-----')
  Log 'filewritable 2: '.filewritable(tmpdir)

" Execute (globpath: extended globbing):
"   " Does not work on Windows.
"   new
"   let tmpdir = tempname()
"   call mkdir(tmpdir)
"   exe 'lcd '.tmpdir
"   call writefile([], 'foo')
"   call writefile([], 'foo-2')
"
"   AssertEqual split(globpath('.', 'foo*'), "\n"), ['./foo', './foo-2']
"   AssertEqual split(globpath('.', '*-2'), "\n"), ['./foo-2']
"   AssertEqual split(globpath('.', 'foo{,-2}'), "\n"), ['./foo', './foo-2']
"   bwipe

Execute (delete: tempname):
  let file = tempname()
  Log file
  call writefile([], file)
  AssertEqual delete(file), 0

Execute (delete: file in tempname: neomaketmp.):
  let dir = tempname()
  call mkdir(dir)
  let file = dir . neomake#utils#Slash() . 'neomaketmp.'
  Log file
  call writefile([], file)
  AssertEqual delete(file), 0

Execute (delete: file in tempname: foo):
  let dir = tempname()
  call mkdir(dir)
  let file = dir . neomake#utils#Slash() . 'foo'
  Log file
  call writefile([], file)
  AssertEqual delete(file), 0
