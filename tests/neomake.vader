" Main entry point to run all Vader tests.
" You can run the included files by itself (since they also include
" include/setup.vader).

~ Features
Include (Completion): completion.vader
Include (Compat): compat.vader
Include (Current working dir): cwd.vader
Include (Environment variables): env.vader
Include (Error handling): errors.vader
Include (Filetype handling): filetypes.vader
Include (Hooks): hooks.vader
Include (Highlights): highlights.vader
Include (Integration tests): integration.vader
Include (JSON): json.vader
Include (Lists): lists.vader
Include (Maker args): args.vader
Include (Makers): makers.vader
Include (Mapexpr): mapexpr.vader
Include (Postprocess): postprocess.vader
Include (Processing): processing.vader
Include (Serialize): serialize.vader
Include (Signs): signs.vader
Include (Statusline): statusline.vader
Include (Temporary files): tempfiles.vader
Include (Utils): utils.vader
Include (Verbosity): verbosity.vader

~ Filetype specific
Include (Haskell): ft_haskell.vader
Include (Perl): ft_perl.vader
Include (Python): ft_python.vader
Include (Shell): ft_sh.vader
Include (Text): ft_text.vader
Include (Elixir): ft_elixir.vader
Include (Elm): ft_elm.vader
Include (PHP): ft_php.vader
Include (Cs): ft_cs.vader
Include (Css): ft_css.vader
Include (Idris): ft_idris.vader
Include (Vim): ft_vim.vader
Include (SQL): ft_sql.vader
Include (Rust): ft_rust.vader
Include (Help): ft_help.vader
Include (Asciidoc): ft_asciidoc.vader
Include (Markdown): ft_markdown.vader
Include (Pandoc): ft_pandoc.vader
Include (Typescript): ft_typescript.vader

* Old/unorganized tests
Include: include/setup.vader

Execute (neomake#GetMakers):
  AssertEqual neomake#GetMakers('non-existent'), []
  AssertEqual neomake#GetMakers('pug'), ['puglint']

  let sh_makers = ['checkbashisms', 'sh', 'shellcheck']
  AssertEqual sort(neomake#GetMakers('sh')), sh_makers

  Save g:neomake_sh_enabled_makers
  let g:neomake_sh_enabled_makers = ['sh']
  AssertEqual sort(neomake#GetMakers('sh')), sh_makers

Execute (neomake#GetMaker with non-existent maker throws errors):
  AssertEqual neomake#GetMaker('non-existent'), {}
  AssertEqual g:neomake_test_messages[-1], [0, 'Invalid maker name: non-existent', {}]
  AssertThrows call neomake#GetMaker('nonexistent')
  AssertEqual g:vader_exception, 'Neomake: project maker not found: nonexistent'

Execute (Neomake with unknown maker):
  " Prevent 'Skipping User autocmd NeomakeCountsChanged: no hooks.' message.
  runtime autoload/neomake/statusline.vim

  Neomake doesnotexist
  let make_id = neomake#GetStatus().last_make_id
  AssertEqual g:neomake_test_messages, [
  \ [0, 'Maker not found (for empty filetype): doesnotexist', {'make_id': make_id}],
  \ [3, 'Nothing to make: no valid makers.', {}]]

Execute (Neomake with unknown maker for multiple fts):
  new
  set filetype=ft1.ft2
  Neomake doesnotexist
  let make_id = neomake#GetStatus().last_make_id
  AssertEqual g:neomake_test_messages, [
  \ [0, 'Maker not found (for filetype ft1.ft2): doesnotexist', {'make_id': make_id}],
  \ [3, 'Nothing to make: no valid makers.', {}]]
  bwipe

Execute (neomake#GetMaker uses defined errorformat with makeprg):
  Save &errorformat
  let &errorformat = '%Gcustom'
  AssertEqual neomake#GetMaker('makeprg', '').errorformat, '%Gcustom'

Execute (neomake#GetMaker uses defaults from b:/g:):
  Save g:neomake_test_remove_invalid_entries
  Save b:neomake_test_remove_invalid_entries

  let maker = {'name': 'test'}

  " Default.
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 0,
  \ "default is ok"

  let maker.remove_invalid_entries = 1
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 1
  let g:neomake_test_remove_invalid_entries = 2
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 2
  let b:neomake_test_remove_invalid_entries = 3
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 3

Execute (neomake#GetMaker uses defaults from b:/g: based on maker):
  Save g:neomake_test_remove_invalid_entries

  let maker = {'name': 'test'}
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 0
  let maker.remove_invalid_entries = 1
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 1
  let g:neomake_test_remove_invalid_entries = 2
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 2
  let b:neomake_test_remove_invalid_entries = 3
  AssertEqual neomake#GetMaker(maker).remove_invalid_entries, 3

Execute (neomake#Make in file mode with no filetype and no makers):
  AssertEqual &ft, ''
  AssertEqual neomake#Make(1, []), []
  let make_id = neomake#GetStatus().last_make_id
  AssertEqual g:neomake_test_messages[-1],
  \ [3, 'Nothing to make: no enabled file mode makers (filetype=).', {'make_id': make_id}]

Execute (neomake#Make in project mode with no filetype and no makers):
  Save makeprg
  let &makeprg = 'sh -c "sleep 0.1"'
  let job_ids = neomake#Make(0, [])
  if neomake#has_async_support()
    AssertEqual len(job_ids), 1
    let jobs = neomake#GetJobs()
    let jobs_by_ids = neomake#GetJobs(job_ids)
    let job_by_id = neomake#GetJob(job_ids[0])
    AssertEqual len(jobs), 1
    AssertEqual jobs, [job_by_id]
    AssertEqual jobs, jobs_by_ids
    AssertEqual job_by_id.maker.name, 'makeprg'
  else
    AssertEqual len(job_ids), 0
  endif

  NeomakeTestsWaitForFinishedJobs

Execute (neomake#GetMaker from g:neomake_foo_maker):
  let g:neomake_custom_maker = {
    \ 'exe': 'my-exe'
    \ }
  let maker = neomake#GetMaker('custom')
  AssertEqual maker.exe, 'my-exe'
  AssertEqual maker.name, 'custom'

Execute (neomake#GetMaker without name):
  let maker = neomake#GetMaker({})
  AssertEqual maker.exe, 'unnamed_maker'
  AssertEqual maker.name, 'unnamed_maker'

Execute (neomake#CancelJob):
  if NeomakeAsyncTestsSetup()
    let job_id = neomake#Sh("sh -c 'while true; do sleep 0.1; done'")
    AssertEqual neomake#CancelJob(job_id), 1

    " The job is still in the table, therefore 'E900: Invalid job id'.
    AssertThrows neomake#CancelJob(job_id)
    AssertNeomakeMessage 'Stopping job', 3, neomake#GetJob(job_id)

    NeomakeTestsWaitForFinishedJobs
    AssertEqual neomake#CancelJob(job_id), 0
    AssertNeomakeMessage 'CancelJob: job not found: '.job_id, 0
  endif

Execute (neomake#CancelJob with invalid job):
  if NeomakeAsyncTestsSetup()
    let job_id = neomake#Sh("sh -c 'sleep .1'")
    let jobinfo = neomake#GetJob(job_id)

    " Stop the job manually.
    if has('nvim')
      call jobstop(job_id)
    else
      let vim_job = jobinfo.vim_job
      call ch_close(vim_job)
    endif

    AssertEqual len(neomake#GetJobs()), 1, 'There are jobs (1)'
    let ret = neomake#CancelJob(job_id)
    AssertEqual len(neomake#GetJobs()), 0, 'There are no more jobs'
    if has('nvim')
      " Vim returns 1 via job_stop usually.
      AssertEqual ret, 0, "CancelJob (1) returned ".ret
    else
      AssertNeomakeMessageAbsent 'exit: job not found: '.job_id
    endif
    AssertNeomakeMessage 'Stopping job', 3, jobinfo
    if has('nvim')
      AssertNeomakeMessage 'jobstop failed: Vim(call):E900: Invalid job id', 2, jobinfo
    else
      AssertNeomakeMessage 'job_stop: job was not running anymore', 2, jobinfo
    endif

    let ret = neomake#CancelJob(job_id)
    if has('nvim')
      " Vim returns 1 via job_stop usually.
      AssertEqual ret, 0, "CancelJob (2) returned ".ret
    endif
    AssertNeomakeMessage 'CancelJob: job not found: '.job_id, 0, {}
    if has('nvim')
      " With Vim the exit callback is not invoked (since ch_close was used).
      NeomakeTestsWaitForNextMessage
      AssertNeomakeMessage 'exit: job not found: '.job_id, 1, {}
    else
      NeomakeCancelJobs!
    endif
    let ret = neomake#CancelJob(job_id)
    AssertEqual ret, 0, "CancelJob (3) returned ".ret
  endif

Execute (neomake#CancelJob! with invalid job):
  if NeomakeAsyncTestsSetup()
    let job_id = neomake#Sh("sh -c 'sleep 0.1'")
    let jobinfo = neomake#GetJob(job_id)

    " Stop the job manually.
    if has('nvim')
      call jobstop(job_id)
    else
      let vim_job = jobinfo.vim_job
      call job_stop(vim_job)
    endif

    AssertEqual len(neomake#GetJobs()), 1, 'There are jobs'
    let ret = neomake#CancelJob(job_id, 1)

    " Jobinfo should have been cleaned already.  With Neovim it gets done
    "" anyway, because jobstop fails.
    Assert !len(neomake#GetJobs()), 'There are no jobs'
    if has('nvim')
      " Vim returns 1 via job_stop usually.
      AssertEqual ret, 0, "CancelJob (1) returned ".ret
    endif
    AssertNeomakeMessageAbsent 'exit: job not found: '.job_id
    AssertNeomakeMessage 'Stopping job', 3, jobinfo
    if has('nvim')
      AssertNeomakeMessage 'jobstop failed: Vim(call):E900: Invalid job id', 2, jobinfo
    endif
    AssertEqual neomake#GetJobs(), []

    AssertEqual neomake#CancelJob(job_id), 0
    AssertNeomakeMessageAbsent 'Stopping job', 3, jobinfo

    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessageAbsent 'exit: job not found: '.job_id
    NeomakeTestsWaitForNextMessage

    AssertNeomakeMessage 'exit: job not found: '.job_id, 1
    AssertEqual neomake#CancelJob(job_id, 1), 0
    AssertNeomakeMessage 'CancelJob: job not found: '.job_id, 0
  endif

Execute (Reports exit status: 7):
  call neomake#Sh("sh -c 'exit 7'")
  let exit_msg = 'sh: sh -c ''exit 7'': completed with exit code 7.'
  if neomake#has_async_support()
    let jobinfo = neomake#GetJobs()[-1]
    NeomakeTestsWaitForFinishedJobs
    AssertNeomakeMessage 'exit: sh: sh -c ''exit 7'': 7', 3, jobinfo
    AssertNeomakeMessage exit_msg, 3, jobinfo
  else
    " XXX: jobinfo gets used in messages, but is hard to get here, so we do not
    "      compare it.
    AssertNeomakeMessage 'exit: sh: sh -c ''exit 7'': 7', 3
    AssertThrows AssertNeomakeMessage exit_msg, 3
    AssertEqual g:vader_exception, 'Vim(call):E121: Undefined variable: exit_msg'
  endif

Execute (neomake#Sh: job_id):
  let job_id = neomake#Sh('true')
  if neomake#has_async_support()
    Assert job_id >= 0, 'Correct job_id for async.'
    NeomakeTestsWaitForFinishedJobs
  else
    Assert job_id == -1, 'Correct job_id for sync.'
  endif

Execute (neomake#CompleteJobs):
  if neomake#has_async_support()
    AssertEqual neomake#CompleteJobs(), ''
    let job_ids = [neomake#Sh('sleep 1')]
    AssertEqual neomake#CompleteJobs(), job_ids[0].': sh: sleep 1'
    let job_ids += [neomake#Sh('sleep 2')]
    AssertEqual neomake#CompleteJobs(), printf(
      \ "%d: sh: sleep 1\n%d: sh: sleep 2", job_ids[0], job_ids[1])
    NeomakeCancelJobs
    NeomakeTestsWaitForFinishedJobs
  endif

Execute (neomake#Make handles invalid cwd):
  let maker = {
      \ 'name': 'custom_maker',
      \ 'exe': 'true',
      \ 'cwd': '/doesnotexist',
      \ }
  call neomake#Make(1, [maker])
  NeomakeTestsWaitForFinishedJobs
  AssertNeomakeMessage "custom_maker: could not change to maker's cwd (/doesnotexist): Vim(cd):E344: Can't find directory \"/doesnotexist\" in cdpath", 0

Execute (Neomake picks up custom maker correctly):
  let g:neomake_c_lint_maker = {
    \ 'exe': 'echo',
    \ 'args': ['%:p', '--foo', 'bar'],
    \ 'append_file': 0,
    \ 'errorformat': '%f:%l:%c: %m',
    \ }
  file file1
  let fname = expand('%:p')
  Save &filetype
  set filetype=c

  Neomake lint
  if neomake#has_async_support()
    AssertNeomakeMessage "Starting async job: ['echo', '".fname."', '--foo', 'bar']"
    NeomakeTestsWaitForFinishedJobs
  else
    AssertNeomakeMessage "Starting: echo ".fname." --foo bar"
  endif
