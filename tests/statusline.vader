Include: include/setup.vader

Execute (LoclistCounts):
  call neomake#statusline#ResetCounts()
  call neomake#statusline#ResetCountsForBuf(99)
  call neomake#statusline#AddLoclistCount(99, {'type': 'E', 'bufnr': 99})
  call neomake#statusline#AddLoclistCount(99, {'type': 'W', 'bufnr': 99})
  AssertEqual neomake#statusline#LoclistCounts(), {}
  " With 'buf ==# "all"' this matched 0.
  AssertEqual neomake#statusline#LoclistCounts(0), {}

  " 0 could refer to current buffer, but does not currently.
  let curbufnr = bufnr('%')
  call neomake#statusline#AddLoclistCount(curbufnr, {'type': 'E', 'bufnr': curbufnr})
  AssertEqual neomake#statusline#LoclistCounts(0), {}

  AssertEqual neomake#statusline#LoclistCounts(1), {}
  AssertEqual neomake#statusline#LoclistCounts(99), {'E': 1, 'W': 1}
  AssertEqual filter(neomake#statusline#LoclistCounts('all'), 'v:key == 99'),
    \ {'99': {'E': 1, 'W': 1}}

Execute (neomake#statusline#ResetCounts):
  call neomake#statusline#ResetCounts()
  call neomake#statusline#AddLoclistCount(99, {'type': 'E', 'bufnr': 99})
  call neomake#statusline#AddLoclistCount(99, {'type': 'W', 'bufnr': 99})
  AssertEqual neomake#statusline#LoclistCounts('all'), {'99': {'E': 1, 'W': 1}}
  call neomake#statusline#AddQflistCount({'type': 'S', 'bufnr': 99})
  AssertEqual neomake#statusline#QflistCounts(), {'S': 1}

  call neomake#statusline#ResetCounts()
  AssertEqual neomake#statusline#LoclistCounts('all'), {}
  AssertEqual neomake#statusline#QflistCounts(), {}

Execute (LoclistCounts returns number):
  call g:NeomakeSetupAutocmdWrappers()
  new
  let bufnr = bufnr('%')
  call neomake#statusline#AddLoclistCount(bufnr, {'type': 'E', 'bufnr': bufnr})
  AssertEqual neomake#statusline#LoclistCounts(bufnr), {'E': 1}
  AssertEqual [], g:neomake_test_countschanged
  call neomake#statusline#ResetCountsForBuf(bufnr)
  AssertEqual bufnr, g:neomake_test_countschanged[0].bufnr
  call setbufvar(g:neomake_test_countschanged[0].bufnr, 'test', 1)
  AssertEqual 1, getbufvar(g:neomake_test_countschanged[0].bufnr, 'test')
  bwipe

Execute (LoclistCounts for wiped buffer should clean s:loclist_counts):
  call g:NeomakeSetupAutocmdWrappers()
  new
  let bufnr = bufnr('%')
  call neomake#statusline#AddLoclistCount(bufnr, {'type': 'E', 'bufnr': bufnr})
  AssertEqual neomake#statusline#LoclistCounts(bufnr), {'E': 1}
  bwipe
  AssertEqual neomake#statusline#LoclistCounts(bufnr), {'E': 1}
  AssertEqual [], g:neomake_test_countschanged

  call neomake#statusline#ResetCounts()
  AssertEqual bufnr, g:neomake_test_countschanged[0].bufnr
  call setbufvar(g:neomake_test_countschanged[0].bufnr, 'test', 1)
  AssertEqual '', getbufvar(g:neomake_test_countschanged[0].bufnr, 'test')

Execute (neomake#statusline#get_status):
  call neomake#statusline#ResetCounts()
  new
  let bufnr = bufnr('')
  AssertEqual neomake#statusline#get_status(bufnr, {}), '?'

  AssertEqual neomake#statusline#get_status(bufnr, {'format_loclist_unknown': '{{running_job_names}}'}), ''
  " {{running_jobs}} is only available with 'format_running' (internally).
  AssertEqual neomake#statusline#get_status(bufnr, {'format_loclist_unknown': '{{running_jobs}}'}), '{{running_jobs}}'
  AssertNeomakeMessage "Error when formatting '{{running_jobs}}': Unknown statusline format: {{running_jobs}}.", 0

  call neomake#Make({'enabled_makers': [g:sleep_maker]})
  if neomake#has_async_support()
    AssertEqual neomake#statusline#get_status(bufnr, {}), '… (sleep-maker)'
    AssertEqual neomake#statusline#get_status(bufnr, {'format_running': '...'}), '...'
    AssertEqual neomake#statusline#get_status(bufnr, {'format_running': ''}), ''
    " format_running=0 disables display of running state.
    AssertEqual neomake#statusline#get_status(bufnr, {'format_running': 0}), '?'
    AssertEqual neomake#statusline#get_status(bufnr, {'format_running': '{{running_job_names}}'}), 'sleep-maker'

    Assert neomake#statusline#get_status(bufnr, {'format_running': '{{running_jobs}}'}) =~# '\m^{''', '{{running_jobs}} is replaced in format_running'

    call neomake#statusline#get_status(bufnr(''), {'format_running': 'Neomake: {{does_not_exist}}'})
    AssertNeomakeMessage "Error when formatting 'Neomake: {{does_not_exist}}': Unknown statusline format: {{does_not_exist}}.", 0
    NeomakeTestsWaitForFinishedJobs
  else
    AssertEqual neomake#statusline#get_status(bufnr, {'format_running': '...'}), '%#NeomakeStatusGood#✓'
    AssertEqual neomake#statusline#get_status(bufnr, {'format_loclist_ok': 'dandy!'}), 'dandy!'
    AssertEqual neomake#statusline#get_status(bufnr, {'format_loclist_ok': '{{running_job_names}}'}), ''
  endif

  call neomake#statusline#get_status(bufnr(''), {'format_loclist_ok': 'Neomake: {{does_not_exist}}'})
  AssertNeomakeMessage "Error when formatting 'Neomake: {{does_not_exist}}': Unknown statusline format: {{does_not_exist}}.", 0
  call neomake#statusline#get_status(bufnr(''), {'format_loclist_ok': '{{foo}} {{bar}}'})
  AssertNeomakeMessage "Errors when formatting '{{foo}} {{bar}}': Unknown statusline format: {{foo}}., Unknown statusline format: {{bar}}.", 0

  AssertEqual neomake#statusline#get_status(bufnr, {}), '%#NeomakeStatusGood#✓'
  Save g:actual_curbuf
  let g:actual_curbuf = bufnr
  AssertEqual neomake#statusline#get(), '%#NeomakeStatusGood#✓'
  call neomake#statusline#ResetCountsForBuf(bufnr)
  AssertEqual neomake#statusline#get_status(bufnr, {}), '?'
  AssertEqual neomake#statusline#get(), '?'
  bwipe

Execute (neomake#statusline#get: clears cache with new job (file mode)):
  new
  let bufnr = bufnr('%')
  Save g:actual_curbuf
  let g:actual_curbuf = bufnr
  CallNeomake {'enabled_makers': [g:error_maker]}
  AssertEqual neomake#statusline#get(), '%#NeomakeStatColorTypeE# E:1 %#NeomakeStatReset#'

  call neomake#Make({'enabled_makers': [g:success_maker]})
  if neomake#has_async_support()
    AssertEqual neomake#statusline#get(), '… (success-maker)'
    NeomakeTestsWaitForFinishedJobs
  endif
  AssertEqual neomake#statusline#get(), '%#NeomakeStatusGood#✓'
  bwipe

Execute (neomake#statusline#get: clears cache with new job (project mode)):
  new
  let bufnr = bufnr('%')
  Save g:actual_curbuf
  let g:actual_curbuf = bufnr
  CallNeomake {'file_mode': 0, 'enabled_makers': [g:error_maker]}
  AssertEqual neomake#statusline#get(), '%#NeomakeStatColorQuickfixTypeE# QE:1 %#NeomakeStatReset#'

  call neomake#Make({'file_mode': 0, 'enabled_makers': [g:true_maker]})
  if neomake#has_async_support()
    AssertEqual neomake#statusline#get(), '… (true-maker!)'
  endif
  call neomake#Make({'file_mode': 0, 'enabled_makers': [g:success_maker]})
  if neomake#has_async_support()
    AssertEqual neomake#statusline#get(), '… (true-maker!, success-maker!)'
    NeomakeTestsWaitForFinishedJobs
  endif
  " Unknown status, only project makers have been run.
  AssertEqual neomake#statusline#get(), '?'
  bwipe

Execute (neomake#statusline#get: clears cache with canceled job: keeps '?'):
  if neomake#has_async_support()
    new
    let bufnr = bufnr('%')
    Save g:actual_curbuf
    let g:actual_curbuf = bufnr
    call neomake#Make({'file_mode': 0, 'enabled_makers': [g:sleep_maker]})
    AssertEqual neomake#statusline#get(), '… (sleep-maker!)'
    NeomakeCancelJobs
    AssertEqual neomake#statusline#get(), '… (sleep-maker!)'
    NeomakeTestsWaitForFinishedJobs
    AssertEqual neomake#statusline#get(), '?'
    bwipe
  else
    NeomakeTestsSkip 'no async support.'
  endif

Execute (neomake#statusline#get: disabling/enabling: clears cache):
  new
  let bufnr = bufnr('%')
  Save g:actual_curbuf
  let g:actual_curbuf = bufnr
  AssertEqual neomake#statusline#get(), '?'
  NeomakeDisableBuffer
  AssertEqual neomake#statusline#get(), 'b- ?'
  AssertNeomakeMessage "Using setting disabled=1 from 'buffer' (statusline#get).", 3, {'bufnr': bufnr}

  NeomakeToggleBuffer
  AssertEqual neomake#statusline#get(), '?'

  CallNeomake 1, [g:true_maker]
  AssertEqual neomake#statusline#get(), '%#NeomakeStatusGood#✓'

  " no-op
  NeomakeEnableBuffer
  AssertEqual neomake#statusline#get(), '%#NeomakeStatusGood#✓'
  bwipe

Execute (neomake#statusline#get: use_highlights_with_defaults):
  new
  let bufnr = bufnr('%')
  Save g:actual_curbuf
  let g:actual_curbuf = bufnr
  AssertEqual neomake#statusline#get({'use_highlights_with_defaults': 0}), '?'
  call neomake#Make({'enabled_makers': [g:entry_maker]})
  AssertEqual neomake#statusline#get({'use_highlights_with_defaults': 0}), '✓'
  AssertEqual neomake#statusline#get({'use_highlights_with_defaults': 1}), '%#NeomakeStatusGood#✓'
  bwipe

Execute (neomake#statusline#get: warning with bufnr):
  AssertEqual neomake#statusline#get(bufnr('%')), '?'
  AssertEqual v:warningmsg, 'Please use neomake#statusline#get with a single dictionary argument.'
  let v:warningmsg = ''
  AssertEqual neomake#statusline#get(bufnr('%')), '?'
  AssertEqual v:warningmsg, ''

Execute (XXX: g:actual_curbuf is set in statusline expressions):
  " This was meant to ensure that g:actual_curbuf is set in statusline
  " expressions, but it turned out that it is not when wrapped in a function,
  " like with Vader's tests.
  " See https://github.com/vim/vim/issues/3279.
  new

  let s:called = 0
  function! Statusline()
    " Tests the current behavior.
    Assert !exists('g:actual_curbuf')
    let s:called = 1
  endfunction

  " NOTE: not being set with just '%!Statusline()' already.
  setlocal statusline=%!'%{Statusline()}'
  redraw

  AssertEqual s:called, 1
  bwipe
  delfunction Statusline
